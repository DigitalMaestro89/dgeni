var _ = require('lodash');
var walk = require('../utils/walk');
var trimIndentation = require('../utils/trim-indentation');
var NEW_LINE = /\n\r?/;
var NGDOC_TAG = /^\s*@(\w+)(\s+(.*))?/;
var INLINE_NGDOC_TAG = /(\{@\w+\s*.*?\s*\})/mg;
var INLINE_NGDOC_TAG_BITS = /\{@(\w+)\s*(.*?)\s*\}/;

module.exports = function ngDocProcessorFactory(tagHandlers, inlineTagHandlers, plugins) {

  /**
   * Process any inline tags within the text of a normal (non-inline) tag
   * @param  {object} tagInfo Info about the tag to process
   * @param  {object} doc     Info about the doc being processed
   */
  function processInlineTags(tagInfo) {
    // Split the tag text into blocks that contain either straight text or inline links
    var blocks = tagInfo.text.split(INLINE_NGDOC_TAG);
    // Are all the blocks strings?
    var allStrings = true;

    // Check each block, if it is an inline tag then process it
    _.forEach(blocks, function(block, index) {

      var match = INLINE_NGDOC_TAG_BITS.exec(block);
      if(match) {

        var inlineName = match[1],
            inlineContent = match[2];

        // Run the handlers stopping on the first that returns a truthy value
        for (var i = 0, ii = inlineTagHandlers.length; i < ii; i++) {
          var result = inlineTagHandlers[i](tagInfo, inlineName, inlineContent);
          if ( !_.isUndefined(result) ) {
            if (  !_.isString(result) && !_.isFunction(result) ) {
              throw new Error('Invalid inline tag handler result. Handlers must only return a string, a function or undefined.', tagInfo, inlineName, inlineContent);
            }
            blocks[index] = result;
            break;
          }
        }
      }

      allStrings = allStrings && _.isString(blocks[index]);
    });

    // If all the blocks are strings just concatenate them
    // If some of the blocks are functions return an aggregator function
    tagInfo.text = allStrings ? blocks.join('') : function() {
      return _.reduce(blocks, function processBlock(text, block) {
        return text + (_.isFunction(block) ? block() : block);
      }, '');
    };
  }

  /**
   * Process the tag by passing it to each of the handlers in turn
   * @param  {object} tagInfo Info about the tag to process
   * @param  {object} doc     Info about the doc being processed
   */
  function processTag(tagInfo) {
    // Convert the lines back to a single text string
    tagInfo.text = trimIndentation(tagInfo.lines.join('\n'));
    delete tagInfo.lines;

    // Process any inline tags on this tag before handing to the tagHandlers
    processInlineTags(tagInfo);

    // Run through each tagHandler, breaking out if one handles the tag
    for (var i = 0, ii = tagHandlers.length; i < ii; i++) {
      if ( tagHandlers[i](tagInfo) ) {
        break;
      }
    }
  }

  /**
   * Process the ngdoc tags in the document
   * @param  {object} doc The document to process - meta data will be added to this by the handlers
   */
  return function processDoc(doc) {
    var currentTag, line;

    // Run the plugins
    plugins.forEach(function(plugin) {
      if ( _.isFunction(plugin.before) ) {
        plugin.before(doc);
      }
    });

    doc.content.split(NEW_LINE).forEach(function(line){
      var match = line.match(NGDOC_TAG);
      if (match) { // we found a new tag!
        
        // in case we are in the middle of parsing a previous tag we process it now
        if ( currentTag ) {
          processTag(currentTag);
        }

        // start a new tag
        currentTag = {
          doc: doc,
          name: match[1],
          lines: match[3] ? [match[3]] : []
        };
      } else if (currentTag) { // we didn't find a new tag but are in still parsing a previous one
        // add this line to the current tag
        currentTag.lines.push(line);
      }
    });

    // we got to the end of the file so process any outstanding tag
    if ( currentTag ) {
      processTag(currentTag);
    }

    // Run the plugins
    plugins.forEach(function(plugin) {
      if ( _.isFunction(plugin.after) ) {
        plugin.after(doc);
      }
    });

    // Call any aggregator functions generated by inline tag handlers to reconstitute the text
    // We do it this way so that inline handlers have access to meta data that may
    // have been generated by the "after" plugins
    walk(doc, function checkAggregator(property, key) {
      var result = _.isFunction(property) ? property() : property;
      return result;
    });

    return doc;
  };
};